---
description: Cursor plan format; always use rich planning aligned with docs/plan-format.md
globs: plans/**/*.md
alwaysApply: false
---

# Plan Authoring (Cursor Format)

**Before writing a plan you MUST use the planner-analyst sub-agent.** See `.cursor/rules/subagent-dispatch.mdc` → Pattern 3. Dispatch the planner-analyst with the user's request, wait for its structured analysis (relevant files, existing data, patterns, risks, rough task breakdown), then write the plan using that output. Do not create a plan from scratch without analyst context.

Create plans as `plans/<name>.md` (not .plan.md). Plans use Cursor format for import into taskgraph via `tg import --format cursor`.

## Import robustness and validation

- **Validate before done**: Run `pnpm tg import plans/<file> --plan "<Plan Name>" --format cursor` to verify the plan imports. If it fails, the CLI now surfaces the underlying YAML parse cause; fix the frontmatter or use a minimal frontmatter and put rich content in the body.
- **Minimal frontmatter (when import fails)**: See [Plan Import Robustness](docs/plan-format.md#plan-import-robustness) in docs/plan-format.md. Use only `name`, single-line `overview`, `todos` with `id`, `content`, `status`, and optional `blockedBy: [id]`. Put intent, fileTree, risks, tests, and suggestedChanges in the **markdown body** so the file still imports. Checklist: no em dash in name; single-line overview; run `tg import` to verify.

## Plan file naming (timestamp convention)

Plan filenames MUST include a date prefix so they sort chronologically. Use this format:

- **Format**: `yy-mm-dd_the_file_name.md` (e.g. `26-02-26_restructure_src_npm_layout.md`). Two-digit year, then date, then underscore, then the plan slug.
- **When to set the date**: Use the plan’s creation date or the date the plan was completed (e.g. when running `tg export markdown` after the last task is done).
- **File name**: Lowercase, words separated by underscores; no spaces or colons (e.g. `multi_agent_centaur`, `fix_failing_tests_properly_4afac574`).
- **New plans / export**: Use current date when creating. Export writes to `exports/<planId>.md` by default; do not write into `plans/` (blocked by CLI).

**Always use the rich planning format** as defined in [docs/plan-format.md](../docs/plan-format.md). Plans are research artifacts: they must carry enough structure and analysis that `tg context` and the executing agent get file trees, risks, tests, and per-task intent/suggested changes.

## Rich planning (required)

Every plan MUST align with the enhanced format in docs/plan-format.md:

| Element              | Required       | Description                                                                                                                                                      |
| -------------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **fileTree**         | yes            | Plan-level. Visual tree of files the plan touches, with `(create)` / `(modify)`. Stored on plan, shown in `tg context`.                                          |
| **risks**            | yes            | Plan-level array of `{ description, severity, mitigation }`. `severity`: `low`, `medium`, `high`.                                                                |
| **tests**            | yes            | Plan-level array of strings describing tests to add.                                                                                                             |
| **intent**           | yes (per todo) | Detailed description of what the task involves and why. Stored on task, shown in `tg context`.                                                                   |
| **suggestedChanges** | when helpful   | Per todo. Directional code snippets or pointers for the agent; not prescriptive.                                                                                 |
| **Markdown body**    | yes            | Below the closing `---`: Analysis, proposed changes, dependency graph, mermaid, risks/testing/open questions. End with `<original_prompt>...</original_prompt>`. |

- **Dependency graph** (required in body): Show the execution order using a visual tree. Group tasks by wave (what can run in parallel vs what is blocked). See format below.
- **Mermaid**: Use for data flows, state machines, or any logic that benefits from a diagram. Can supplement the dependency graph.
- **suggestedChanges**: Add when a task touches a specific file/function; a short snippet speeds the agent up.

## Visual trees

Use `├──` / `└──` tree drawing for both **file trees** and **dependency graphs**. This format is more scannable than flat lists or indented bullets.

### fileTree (YAML frontmatter)

```yaml
fileTree: |
  src/
  ├── db/
  │   └── migrate.ts            (modify)
  ├── domain/
  │   └── types.ts              (modify)
  └── plan-import/
      ├── parser.ts             (modify)
      └── importer.ts           (modify)
  __tests__/
  └── integration/
      └── rich-plan.test.ts     (create)
```

### Dependency graph (markdown body)

Show execution waves — what can run in parallel and what is gated. Use tree connectors within each wave.

```textmarkdown
Parallel start (3 unblocked):
  ├── create-registry-rule
  ├── schema-migration (migrate.ts + types.ts)
  └── update-docs (plan-format.md + authoring rule)

After schema-migration:
  ├── update-parser
  ├── update-importer
  └── update-context-cmd

After registry + context-cmd:
  └── update-dispatch-rule

After parser + importer + context-cmd:
  └── integration-tests
```

Include this graph in the markdown body of every plan. It complements mermaid (which is better for data flows and state machines) — the tree graph is the quick-scan execution plan.

## YAML Frontmatter Structure

```yaml
---
name: Plan Name
overview: |
  Multi-line overview; can include why and scope.
fileTree: |
  src/
  ├── db/
  │   └── migrate.ts            (modify)
  └── domain/
      └── types.ts              (modify)
risks:
  - description: What could go wrong
    severity: medium
    mitigation: How we address it
tests:
  - "Test description 1"
  - "Test description 2"
todos:
  - id: stable-key
    content: "Task title (concise; under 255 chars)"
    intent: |
      Detailed scope, rationale, and references to code.
    suggestedChanges: |
      Optional snippet or pointer for the agent.
    blockedBy: [other-id]
    domain: [schema, cli]
    skill: [cli-command-implementation]
    changeType: modify
isProject: false
---
```

Below the closing `---`, add the markdown body: **Analysis**, **Dependency graph** (tree format), **Proposed changes** (or Mermaid), **Open questions**, and end with `<original_prompt>...</original_prompt>`.

## Todo Fields

| Field              | Required | Description                                                                   |
| ------------------ | -------- | ----------------------------------------------------------------------------- |
| `id`               | yes      | Stable key → maps to `external_key`. Use kebab-case.                          |
| `content`          | yes      | Task title (maps to task title; VARCHAR(255) — keep under 255 chars).         |
| `intent`           | yes      | Detailed scope and rationale; stored on task, shown in `tg context`.          |
| `status`           | no       | `pending` → todo, `completed` → done                                          |
| `blockedBy`        | no       | Array of todo `id`s that block this task. Creates `blocks` edges on import.   |
| `docs`             | no       | Single slug or array → `docs/<slug>.md`. Agent reads these before starting.   |
| `agent`            | yes      | Single slug or array → specifies the agent or sub-agent to execute this task. |
| `skill`            | no       | Single slug or array → `docs/skills/<skill>.md`. Use kebab-case.              |
| `changeType`       | no       | `create`, `modify`, `refactor`, `fix`, `investigate`, `test`, `document`.     |
| `suggestedChanges` | no       | Directional snippets for the agent when the task touches specific code.       |

## Choosing agent

- For fix/debug tasks where root cause is unclear or repro is needed, set `agent: debugger` so the dispatcher uses the systematic debugging template.

## Assigning docs and skills

When authoring todos, use the `docs` field to reference documentation pages that provide domain context or additional instructions. The value should be a single slug or an array of slugs corresponding to files under `docs/`. The agent will load these files before executing the task.

Use the `skill` field to specify a specialized Cursor skill for the task, referenced by its slug (e.g., `my-skill` for `docs/skills/my-skill.md`). Skills extend agent capabilities and should be included only when a task requires functionality beyond the core agent commands.

## Dependency and scope

- Use `blockedBy` for tasks that cannot start until others are done.
- Reference `id` values; they resolve to task IDs when importing.
- Keep tasks scoped (~90 min or less); split large ones.
- **Parallel-ready**: Plans MUST have ≥2 tasks with no `blockedBy` so the orchestrator can dispatch in parallel. If all tasks are serial, restructure: docs, tests, and independent features rarely need to block on each other. For each `blockedBy`, ask "can this task work without the upstream?" — if yes, remove the dependency.
- Order todos to reflect dependency graph when possible.

## Required end-of-plan structure

Every plan MUST end with:

1. **Add-tests task(s)** — One or more tasks that create tests for the new features, or assign plan-level tests (from the plan’s `tests` array) to such tasks. These tasks validate that the implemented behavior is covered by tests.

2. **Run-full-suite task** — A final task that runs the full test suite (e.g. `pnpm gate:full` or `bash scripts/cheap-gate.sh --full`). This task:
   - Records the result in **evidence** (e.g. "gate:full passed" or "gate:full failed: ...").
   - On **failure**: the agent adds `tg note <taskId> --msg "<failure reason>"` and either does not mark the task done, or marks it done with failure described in evidence so the lead can create fix tasks.

**Dependency graph:** The add-tests and run-full-suite tasks must be **blocked by all feature work**. In the dependency graph (tree format above), they appear in a final wave, e.g.:

```text
After all feature work:
  ├── add-tests (or multiple add-tests tasks)
  └── run-full-suite   # blocked by add-tests / last feature tasks
```

Use `blockedBy: [id1, id2, ...]` so the run-full-suite task (and add-tests tasks if they depend on feature tasks) cannot run until the preceding work is done.

**Note:** This is authoring guidance only. Import logic is unchanged; the parser does not enforce this structure.
