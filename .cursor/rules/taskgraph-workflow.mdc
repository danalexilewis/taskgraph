---
description: Task-Graph plan creation, review protocol, import, and execution loop
alwaysApply: true
---

# Task-Graph Workflow

## Build and dist

- **Integration tests** run the built CLI from `dist/`. After changing anything under `src/`, run `pnpm build` before `pnpm test:integration` if you need tests to see the latest code.
- **On-stop hook:** `.cursor/hooks/rebuild-if-src-changed.js` runs when the agent stops. If there are uncommitted changes under `src/`, it runs `pnpm build` then `bash scripts/cheap-gate.sh` so dist stays in sync and lint/typecheck/affected-tests run. Rely on this at end of session; no need to manually rebuild unless you are about to run integration tests mid-session.

## Validation pipeline

- **Lint:** `pnpm lint` (biome check), `pnpm lint:fix` (biome check --write).
- **Typecheck:** `pnpm typecheck` runs typecheck only on **changed** `src/**/*.ts` (from git); `pnpm typecheck:all` runs full `tsc --noEmit`. Default is changed-files so sub-agents and gate stay fast. See `.cursor/rules/changed-files-default.mdc`.
- **Gate:** `pnpm gate` runs `scripts/cheap-gate.sh` (lint + typecheck on changed files + affected tests). `pnpm gate:full` runs lint + full typecheck + full test suite.
- **Recommendation:** After making changes, run `pnpm gate` (or `bash scripts/cheap-gate.sh`) to validate before committing.

## Orientation

Before executing any plan, run `pnpm tg status` to see what's outstanding. **Multi-agent:** Check "Active work" for other agents' tasks; avoid overlapping on the same files/area. If overlap is detected, use `tg note <taskId> --msg "..."` to signal and pick a different task. If there are stale `doing` tasks or forgotten `todo` tasks for completed work, clean them up first (see Recovery below).

## Plan Creation and Review

- **Plans** live in `plans/<date>_<name>.md` in Cursor format (YAML frontmatter with `name`, `overview`, `todos`). Filenames use the convention `yy-mm-dd_the_file_name.md` (see plan-authoring.mdc).
- After creating a plan: summarize it, then **pause** and ask for review. Do not import or execute until the user responds.

### Interpreting User Response

| User says                                              | Action                                       |
| ------------------------------------------------------ | -------------------------------------------- |
| proceed, go ahead, execute, run it, let's do it        | Import plan to taskgraph, then execute tasks |
| just add the tasks, add to taskgraph only              | Import only; do not execute                  |
| thanks, that's good, looks good, ok, don't do anything | Do nothing (acknowledgement only)            |

### Import Command

```bash
pnpm tg import plans/<file> --plan "<Plan Name>" --format cursor
```

## Execution Loop — MANDATORY sub-agent dispatch

Task execution uses sub-agents. Follow `.cursor/rules/subagent-dispatch.mdc` Pattern 1 (parallel) or Pattern 2 (sequential). The orchestrator coordinates; sub-agents do the work.

**Task orchestration UI**: Before dispatching sub-agents for tg tasks, call TodoWrite with the task list from `tg next` and update statuses as tasks complete. When dispatching a batch, emit N Task (or mcp_task) calls in the same turn. See subagent-dispatch.mdc for the full TodoWrite and batch-in-one-turn protocol.

1. `pnpm tg next --plan "<Plan>" --json --limit 20` — get runnable tasks; batch all non-conflicting (Cursor decides concurrency)
2. For each task: build implementer prompt from `tg context` and `.cursor/agents/implementer.md`; dispatch via Task tool, agent CLI, or mcp_task.
3. After implementer completes: dispatch reviewer with task context + diff.
4. If reviewer FAILs, re-dispatch implementer once. After 2 failures, fall back to direct execution.
5. **Follow-up from notes/evidence**: If the implementer's return or task notes mention environment issues, gate failures, or suggested follow-up, the orchestrator decides whether to investigate — if yes, create task(s) with `tg task new ... --plan <planId>` and delegate them (see subagent-dispatch.mdc → Follow-up from notes/evidence).

### Fallback: direct execution

Use only when: a sub-agent has failed twice on the same task, or the task is explicitly exploratory/ambiguous. In this case follow the direct steps:

1. `pnpm tg start <taskId> --agent <name>`
2. `pnpm tg context <taskId>` — read and load docs
3. Do the work
4. `pnpm tg done <taskId> --evidence "..."`
5. Log the reason: `pnpm tg note <taskId> --msg "Direct execution: <reason>"`

Evidence should include: tests run, commands, git hashes.

### Multi-task discipline

When executing N tasks in sequence, complete the full start→work→done cycle for each one individually. Never batch-skip transitions.

### Plan completion

After marking the last task in a plan as done, run:

```bash
pnpm tg export markdown --plan <planId>
```

Export writes to `exports/<planId>.md` by default (gitignored). Plan files in `plans/` are never overwritten by export.

## Recovery (out-of-sync tasks)

If work is already done but the task is still `todo` or `doing` in taskgraph:

- **Task is `todo`**: `pnpm tg done <taskId> --force --evidence "completed previously"`
- **Task is `doing`**: `pnpm tg done <taskId> --evidence "completed previously"`

Run `pnpm tg status` after cleanup to verify.

## When Blocked

- `pnpm tg block <taskId> --on <blockerId> --reason "..."`
- If blocker does not exist: create a new task with owner=human, then block on it.
