---
description: Task-Graph plan creation, review protocol, import, and execution loop
alwaysApply: true
---

# Task-Graph Workflow

## Orientation

Before executing any plan, run `pnpm tg status` to see what's outstanding. **Multi-agent:** Check "Active work" for other agents' tasks; avoid overlapping on the same files/area. If overlap is detected, use `tg note <taskId> --msg "..."` to signal and pick a different task. If there are stale `doing` tasks or forgotten `todo` tasks for completed work, clean them up first (see Recovery below).

## Plan Creation and Review

- **Plans** live in `plans/<date>_<name>.md` in Cursor format (YAML frontmatter with `name`, `overview`, `todos`). Filenames use the convention `yy-mm-dd_the_file_name.md` (see plan-authoring.mdc).
- After creating a plan: summarize it, then **pause** and ask for review. Do not import or execute until the user responds.

### Interpreting User Response

| User says                                              | Action                                       |
| ------------------------------------------------------ | -------------------------------------------- |
| proceed, go ahead, execute, run it, let's do it        | Import plan to taskgraph, then execute tasks |
| just add the tasks, add to taskgraph only              | Import only; do not execute                  |
| thanks, that's good, looks good, ok, don't do anything | Do nothing (acknowledgement only)            |

### Import Command

```bash
pnpm tg import plans/<file> --plan "<Plan Name>" --format cursor
```

## Execution Loop — MANDATORY sub-agent dispatch

Task execution uses sub-agents. Follow `.cursor/rules/subagent-dispatch.mdc` Pattern 1 (parallel) or Pattern 2 (sequential). The orchestrator coordinates; sub-agents do the work.

**Task orchestration UI**: Before dispatching sub-agents for tg tasks, call TodoWrite with the task list from `tg next` and update statuses as tasks complete. When dispatching a batch, emit N Task (or mcp_task) calls in the same turn. See subagent-dispatch.mdc for the full TodoWrite and batch-in-one-turn protocol.

1. `pnpm tg next --plan "<Plan>" --json --limit 20` — get runnable tasks; batch all non-conflicting (Cursor decides concurrency)
2. For each task: build implementer prompt from `tg context` and `.cursor/agents/implementer.md`; dispatch via Task tool, agent CLI, or mcp_task.
3. After implementer completes: dispatch reviewer with task context + diff.
4. If reviewer FAILs, re-dispatch implementer once. After 2 failures, fall back to direct execution.

### Fallback: direct execution

Use only when: a sub-agent has failed twice on the same task, or the task is explicitly exploratory/ambiguous. In this case follow the direct steps:

1. `pnpm tg start <taskId> --agent <name>`
2. `pnpm tg context <taskId>` — read and load docs
3. Do the work
4. `pnpm tg done <taskId> --evidence "..."`
5. Log the reason: `pnpm tg note <taskId> --msg "Direct execution: <reason>"`

Evidence should include: tests run, commands, git hashes.

### Multi-task discipline

When executing N tasks in sequence, complete the full start→work→done cycle for each one individually. Never batch-skip transitions.

### Plan completion

After marking the last task in a plan as done, run:

```bash
pnpm tg export markdown --plan <planId>
```

Export writes to `exports/<planId>.md` by default (gitignored). Plan files in `plans/` are never overwritten by export.

## Recovery (out-of-sync tasks)

If work is already done but the task is still `todo` or `doing` in taskgraph:

- **Task is `todo`**: `pnpm tg done <taskId> --force --evidence "completed previously"`
- **Task is `doing`**: `pnpm tg done <taskId> --evidence "completed previously"`

Run `pnpm tg status` after cleanup to verify.

## When Blocked

- `pnpm tg block <taskId> --on <blockerId> --reason "..."`
- If blocker does not exist: create a new task with owner=human, then block on it.
